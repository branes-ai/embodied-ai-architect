// Optimized ALU - generated by LLM optimizer
// Attempted optimizations:
// 1. Shared adder for add/sub (CORRECT)
// 2. Reused subtraction for comparison (CORRECT)
// 3. Async reset (CORRECT but may cause issues)
// 4. Removed barrel shifter (INCORRECT - changes functionality!)

module alu_optimized #(
    parameter WIDTH = 8
)(
    input  wire                clk,
    input  wire                rst,
    input  wire [WIDTH-1:0]    a,
    input  wire [WIDTH-1:0]    b,
    input  wire [3:0]          op,
    input  wire                valid_in,
    output reg  [WIDTH-1:0]    result,
    output reg                 zero,
    output reg                 overflow,
    output reg                 valid_out
);

    // Operation codes
    localparam OP_ADD  = 4'b0000;
    localparam OP_SUB  = 4'b0001;
    localparam OP_AND  = 4'b0010;
    localparam OP_OR   = 4'b0011;
    localparam OP_XOR  = 4'b0100;
    localparam OP_SHL  = 4'b0101;
    localparam OP_SHR  = 4'b0110;
    localparam OP_LT   = 4'b0111;
    localparam OP_EQ   = 4'b1000;
    localparam OP_PASS = 4'b1001;

    // OPTIMIZATION 1: Single adder with carry-in for add/sub
    wire [WIDTH:0] addsub_result;
    wire subtract = (op == OP_SUB) || (op == OP_LT) || (op == OP_EQ);
    wire [WIDTH-1:0] b_mux = subtract ? ~b : b;
    assign addsub_result = {1'b0, a} + {1'b0, b_mux} + {{WIDTH{1'b0}}, subtract};
    
    // OPTIMIZATION 2: Reuse subtraction for comparisons
    wire lt_result = addsub_result[WIDTH];  // Sign bit of subtraction
    wire eq_result = (addsub_result[WIDTH-1:0] == {WIDTH{1'b0}});
    
    // Result computation
    reg [WIDTH-1:0] result_comb;
    reg overflow_comb;
    
    always @(*) begin
        result_comb = {WIDTH{1'b0}};
        overflow_comb = 1'b0;
        
        case (op)
            OP_ADD: begin
                result_comb = addsub_result[WIDTH-1:0];
                overflow_comb = addsub_result[WIDTH];
            end
            
            OP_SUB: begin
                result_comb = addsub_result[WIDTH-1:0];
                overflow_comb = addsub_result[WIDTH];
            end
            
            OP_AND: result_comb = a & b;
            OP_OR:  result_comb = a | b;
            OP_XOR: result_comb = a ^ b;
            
            // BUG: LLM "simplified" the shifter incorrectly!
            // Original: shift by b[2:0] (0-7 positions)
            // Broken: always shifts by 1
            OP_SHL: result_comb = a << 1;  // BUG: should be a << b[2:0]
            OP_SHR: result_comb = a >> 1;  // BUG: should be a >> b[2:0]
            
            OP_LT: result_comb = {{(WIDTH-1){1'b0}}, lt_result};
            OP_EQ: result_comb = {{(WIDTH-1){1'b0}}, eq_result};
            
            OP_PASS: result_comb = a;
            
            default: result_comb = {WIDTH{1'b0}};
        endcase
    end
    
    // OPTIMIZATION 3: Async reset (saves area but may cause issues)
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            result    <= {WIDTH{1'b0}};
            zero      <= 1'b0;
            overflow  <= 1'b0;
            valid_out <= 1'b0;
        end else begin
            result    <= result_comb;
            zero      <= (result_comb == {WIDTH{1'b0}});
            overflow  <= overflow_comb;
            valid_out <= valid_in;
        end
    end

endmodule
